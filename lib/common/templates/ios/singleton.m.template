//  Do not edit directly
//  Generated on <%= new Date() %>

#import "<%= this.className %>.h"

@implementation <%= this.className %>

+ (NSDictionary *)getProperty:(NSString *)keyPath {
  return [[self properties] valueForKeyPath:keyPath];
}

+ (nonnull)getValue:(NSString *)keyPath {
  return [[self properties] valueForKeyPath:[NSString stringWithFormat:@"%@.value", keyPath]];
}

+ (NSDictionary *)properties {
  static NSDictionary * dictionary;
  static dispatch_once_t onceToken;

  dispatch_once(&onceToken, ^{
    dictionary = <%= buildDictionary(properties) %>;
  });

  return dictionary;
}

@end

<% function buildDictionary(props, indent) {
  indent = indent || '  ';
  if (props.hasOwnProperty('value')) {
    var to_ret = '@{\n';
    var value = props.attributes.category === 'size' ? '@' + props.value : props.value;
    to_ret += indent + '@"value": ' + value + ',\n';
    to_ret += indent + '@"name": @"' + props.name + '",\n';

    for(var name in props.attributes) {
      if (props.attributes[name]) {
        to_ret += indent + '@"' + name + '": @"' + props.attributes[name] + '",\n';
      }
    }

    // remove last comma
    return to_ret.slice(0, -2) + '\n' + indent + '}';
  } else {
    var to_ret = '@{\n';
    for(var name in props) {
      to_ret += indent + '@"' + name + '": ' + buildDictionary(props[name], indent + '  ') + ',\n';
    }
    // remove last comma
    return to_ret.slice(0, -2) + '\n' + indent + '}';
  }
} %>
